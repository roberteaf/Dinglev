<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Mines & Plinko</title>
  <style>
    :root {
      --bg1: #a0eaff;
      --bg2: #ff9aa2;
      --accent: #7af0c2;
      --muted: #8fa3b3;
      --card-bg: #0b0d18;
      --glass: rgba(255,255,255,0.02);
    }
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { height:100%; }
    body {
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      background-size: 400% 400%;
      animation: bgShift 20s ease infinite;
      color: #e6eef8;
      min-height:100vh;
      font-family: Inter, system-ui, sans-serif;
    }
    @keyframes bgShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .topbar {
      position:fixed;
      top:18px; left:18px;
      z-index:10;
      display:flex;
      gap:10px;
    }
    .switch-btn {
      background: var(--card-bg);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 10px;
      padding: 10px 18px;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transition: background 0.2s, color 0.2s;
    }
    .switch-btn.active {
      background: var(--accent);
      color: #0b0d18;
    }
    .container {
      width:100%;
      max-width:1000px;
      margin:80px auto 0 auto;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:20px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)), var(--card-bg);
      border-radius:12px;
      padding:18px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .hidden { display:none !important; }
    /* Mines game styles (copied from your code) */
    .balance {
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .balance .amount {
      font-size:28px;
      font-weight:700;
      color: var(--accent);
    }
    .balance .label {
      color: var(--muted);
      font-size:13px;
    }
    input[type=number] {
      width:140px;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:inherit;
      font-weight:600;
      transition: border-color 0.3s;
    }
    input[type=number]:focus {
      border-color: var(--accent);
      outline: none;
    }
    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:inherit;
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 22px rgba(0,0,0,0.7);
    }
    .btn-primary {
      background: linear-gradient(90deg, var(--accent), #a0f9d8);
      border:none;
      color:#0b0d18;
      box-shadow: 0 6px 18px rgba(122,240,194,0.2);
    }
    .toggle {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px;
      border-radius:10px;
      background: var(--glass);
      border:1px solid rgba(255,255,255,0.02);
    }
    .toggle input {
      width:16px; height:16px;
    }
    .toggle span {
      color: var(--muted);
      font-size:13px;
    }
    .grid {
      display:grid;
      grid-template-columns: repeat(5,1fr);
      gap:6px;
      margin-top:12px;
    }
    .cell {
      position: relative;
      background: var(--glass);
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      cursor:pointer;
      user-select:none;
      aspect-ratio:1;
      overflow:hidden;
      transition: background 0.3s;
    }
    .cell:hover {
      background: rgba(255,255,255,0.06);
    }
    .cell.revealed {
      cursor: default;
      background: rgba(255,255,255,0.08);
    }
    .cell.mine {
      background: linear-gradient(135deg, #001a33, #004f66);
      color: #ff6666;
    }
    .cell.safe {
      background: linear-gradient(135deg, #002244, #33cc88);
      color: #ccffee;
    }
    .cell .inner {
      transform: scale(0);
      transition: transform 0.3s ease-out;
      z-index:5;
    }
    .cell.revealed .inner {
      transform: scale(1);
    }
    .history {
      margin-top:12px;
      max-height:300px;
      overflow:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:10px;
    }
    .history-item {
      display:flex;
      justify-content:space-between;
      padding:6px;
      border-radius:8px;
      margin-bottom:6px;
      transition: background 0.3s;
    }
    .history-item.win {
      background: linear-gradient(90deg, rgba(64,255,192,0.05), rgba(255,255,255,0.01));
    }
    .history-item.loss {
      background: linear-gradient(90deg, rgba(255,72,72,0.04), rgba(255,255,255,0.01));
    }
    .small { font-size:12px; color: var(--muted); }
    /* Plinko styles */
    .plinko-canvas {
      width: 100%;
      height: 500px;
      background: linear-gradient(180deg, #0b0d18 80%, #1a2a38 100%);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.7);
      display: block;
      margin: 0 auto;
      border: 1px solid rgba(255,255,255,0.04);
    }
    .plinko-payouts {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      gap: 2px;
    }
    .plinko-payout {
      flex: 1;
      text-align: center;
      font-weight: bold;
      color: var(--accent);
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      padding: 4px 0;
      font-size: 15px;
    }
    .plinko-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .plinko-history {
      margin-top: 12px;
      max-height: 120px;
      overflow: auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <button class="switch-btn active" id="btnMines">Mines</button>
    <button class="switch-btn" id="btnPlinko">Plinko</button>
  </div>
  <div class="container">
    <!-- Mines Game -->
    <div class="card left-col" id="minesGame">
      <div class="balance">
        <div>
          <div class="label">Balance</div>
          <div class="amount" id="balanceDisplay">1,000,000</div>
        </div>
        <div>
          <label class="toggle" title="Infinite money (fun mode)">
            <input id="infiniteToggle" type="checkbox" />
            <span class="small">Infinite</span>
          </label>
        </div>
      </div>
      <div class="small muted" style="margin-top:8px;">
        Reveal tiles â avoid mines! Cash out before you explode.
      </div>
      <div class="grid" id="grid"></div>
      <div style="margin-top:12px; display:flex; gap:12px; align-items:center;">
        <button id="cashoutBtn" class="btn-primary" disabled>Cash Out</button>
        <div id="statusLabel" class="small"></div>
      </div>
    </div>
    <div class="card right-col" id="minesControls">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="flex:1">
          <div class="label small">Bet</div>
          <input type="number" id="betInput" min="1" step="1" value="1000" />
        </div>
        <div>
          <label class="toggle">
            <input type="number" id="mineCount" value="3" min="1" max="10" style="width:60px;" />
            <span class="small">Mines</span>
          </label>
        </div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
        <button id="startBtn" class="btn-primary" style="flex:1;">Start Game</button>
        <label class="toggle">
          <input type="checkbox" id="autoCashout" />
          <span class="small">Auto Cashout</span>
        </label>
      </div>
      <div style="margin-top:12px; flex:1;">
        <div class="small muted">History</div>
        <div class="history" id="history"></div>
      </div>
    </div>
    <!-- Plinko Game -->
    <div class="card left-col hidden" id="plinkoGame">
      <div class="balance">
        <div>
          <div class="label">Balance</div>
          <div class="amount" id="plinkoBalanceDisplay">1,000,000</div>
        </div>
        <div>
          <label class="toggle" title="Infinite money (fun mode)">
            <input id="plinkoInfiniteToggle" type="checkbox" />
            <span class="small">Infinite</span>
          </label>
        </div>
      </div>
      <div class="small muted" style="margin-top:8px;">
        Drop the ball! Where will it land?
      </div>
      <canvas class="plinko-canvas" id="plinkoCanvas" width="350" height="500"></canvas>
      <div class="plinko-payouts" id="plinkoPayouts"></div>
      <div class="plinko-controls">
        <div>
          <div class="label small">Bet</div>
          <input type="number" id="plinkoBetInput" min="1" step="1" value="1000" />
        </div>
        <button id="plinkoDropBtn" class="btn-primary">Drop Ball</button>
      </div>
      <div class="plinko-history" id="plinkoHistory"></div>
    </div>
    <div class="card right-col hidden" id="plinkoControls">
      <div class="small muted">Plinko Info</div>
      <div style="margin-top:10px;">
        <div class="small">Payouts increase as you go outwards. Middle slot pays 0.2x, next 0.5x, then 1x, 2x, and 10x at the edges.</div>
        <div class="small" style="margin-top:10px;">Try to hit the sides for big wins!</div>
      </div>
    </div>
  </div>
<script>
(() => {
  // --- Shared Economy State ---
  const STORAGE_KEY = 'mines_plinko_econ_v1';
  const defaultState = {
    balance: 1_000_000,
    infinite: true,
    history: [],
    plinkoHistory: []
  };
  let state = loadState();

  function loadState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return {...defaultState};
      const p = JSON.parse(raw);
      p.balance = typeof p.balance === 'number' ? p.balance : defaultState.balance;
      p.infinite = !!p.infinite;
      p.history = Array.isArray(p.history) ? p.history : [];
      p.plinkoHistory = Array.isArray(p.plinkoHistory) ? p.plinkoHistory : [];
      return p;
    } catch(e) {
      return {...defaultState};
    }
  }
  function saveState(){
    const to = {
      balance: state.balance,
      infinite: state.infinite,
      history: state.history.slice(-200),
      plinkoHistory: state.plinkoHistory.slice(-100)
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(to));
  }
  function fmt(n){
    if (n === Infinity) return 'â';
    return n >= 1000 ? n.toLocaleString() : '' + n;
  }

  // --- UI Switch ---
  const btnMines = document.getElementById('btnMines');
  const btnPlinko = document.getElementById('btnPlinko');
  const minesGame = document.getElementById('minesGame');
  const minesControls = document.getElementById('minesControls');
  const plinkoGame = document.getElementById('plinkoGame');
  const plinkoControls = document.getElementById('plinkoControls');

  function showGame(game) {
    if (game === 'mines') {
      minesGame.classList.remove('hidden');
      minesControls.classList.remove('hidden');
      plinkoGame.classList.add('hidden');
      plinkoControls.classList.add('hidden');
      btnMines.classList.add('active');
      btnPlinko.classList.remove('active');
      renderBalance();
    } else {
      minesGame.classList.add('hidden');
      minesControls.classList.add('hidden');
      plinkoGame.classList.remove('hidden');
      plinkoControls.classList.remove('hidden');
      btnMines.classList.remove('active');
      btnPlinko.classList.add('active');
      renderPlinkoBalance();
    }
  }
  btnMines.onclick = () => showGame('mines');
  btnPlinko.onclick = () => showGame('plinko');

  // --- Mines Game (from your code, slightly adapted for shared balance) ---
  const balanceDisplay = document.getElementById('balanceDisplay');
  const infiniteToggle = document.getElementById('infiniteToggle');
  const betInput = document.getElementById('betInput');
  const startBtn = document.getElementById('startBtn');
  const mineCountInput = document.getElementById('mineCount');
  const autoCashout = document.getElementById('autoCashout');
  const gridEl = document.getElementById('grid');
  const cashoutBtn = document.getElementById('cashoutBtn');
  const statusLabel = document.getElementById('statusLabel');
  const historyEl = document.getElementById('history');

  function renderBalance(){
    balanceDisplay.textContent = state.infinite ? 'â' : fmt(state.balance);
  }
  function renderHistory(){
    historyEl.innerHTML = '';
    const items = state.history.slice().reverse();
    if (items.length === 0) {
      historyEl.innerHTML = `<div class="small muted">No history yet.</div>`;
      return;
    }
    for (const it of items) {
      const el = document.createElement('div');
      el.className = 'history-item ' + (it.profit >= 0 ? 'win' : 'loss');
      el.innerHTML = `
        <div>${it.result}</div>
        <div>${it.profit >= 0 ? '+' : ''}${fmt(it.profit)}</div>
      `;
      historyEl.appendChild(el);
    }
  }

  let game = null;
  function resetGame(){
    game = null;
    gridEl.innerHTML = '';
    cashoutBtn.disabled = true;
    statusLabel.textContent = '';
  }
  function startGame(){
    resetGame();
    const bet = Math.floor(Number(betInput.value));
    if (!Number.isFinite(bet) || bet < 1) {
      alert('Enter a valid bet');
      return;
    }
    if (!state.infinite && bet > state.balance) {
      alert('Not enough balance');
      return;
    }
    const mines = Math.floor(Number(mineCountInput.value));
    if (!Number.isFinite(mines) || mines < 1 || mines >= 25) {
      alert('Mines must be between 1 and 24');
      return;
    }
    const total = 25;
    const minePos = new Set();
    while (minePos.size < mines) {
      minePos.add(Math.floor(Math.random() * total));
    }
    game = { bet, mines, minePos, opened: new Set(), currentPayout: 0 };
    if (!state.infinite) {
      state.balance -= bet;
    }
    for (let i=0; i<25; i++){
      const c = document.createElement('div');
      c.className = 'cell';
      c.dataset.idx = i;
      c.addEventListener('click', cellClick);
      const inner = document.createElement('div');
      inner.className = 'inner';
      c.appendChild(inner);
      gridEl.appendChild(c);
    }
    cashoutBtn.disabled = false;
    statusLabel.textContent = `Opened 0 safe / ${mines} mines`;
    renderBalance();
    saveState();
  }
  function cellClick(ev){
    if (!game) return;
    const idx = +ev.currentTarget.dataset.idx;
    if (game.opened.has(idx)) return;
    game.opened.add(idx);
    const cell = ev.currentTarget;
    const inner = cell.querySelector('.inner');
    if (game.minePos.has(idx)) {
      cell.classList.add('revealed', 'mine');
      inner.textContent = 'ð£';
      endGame(false);
    } else {
      cell.classList.add('revealed', 'safe');
      inner.textContent = '';
      const safeCount = game.opened.size;
      statusLabel.textContent = `Opened ${safeCount} safe / ${game.mines} mines`;
      const multiplier = 1 + safeCount * 0.1;
      game.currentPayout = game.bet * multiplier;
      if (autoCashout.checked) {
        cashOut();
      }
    }
  }
  function endGame(win){
    for (const idx of game.minePos) {
      const c = gridEl.querySelector(`.cell[data-idx='${idx}']`);
      if (c && !c.classList.contains('revealed')) {
        c.classList.add('revealed','mine');
        c.querySelector('.inner').textContent = 'ð£';
      }
    }
    cashoutBtn.disabled = true;
    if (!win) {
      statusLabel.textContent = `ð¥ Boom! You lost -${fmt(game.bet)}`;
      state.history.push({ result: 'Loss', profit: -game.bet });
    }
    renderBalance();
    renderHistory();
    saveState();
    game = null;
  }
  function cashOut(){
    if (!game) return;
    const profit = Math.floor(game.currentPayout) - game.bet;
    if (!state.infinite) {
      state.balance += Math.floor(game.currentPayout);
    }
    statusLabel.textContent = `Cashed out +${fmt(profit)}`;
    state.history.push({ result: 'Win', profit });
    saveState();
    renderBalance();
    renderHistory();
    endGame(true);
  }
  startBtn.addEventListener('click', startGame);
  cashoutBtn.addEventListener('click', cashOut);
  infiniteToggle.addEventListener('change', () => {
    state.infinite = infiniteToggle.checked;
    renderBalance();
    saveState();
  });

  // --- Plinko Game ---
  const plinkoBalanceDisplay = document.getElementById('plinkoBalanceDisplay');
  const plinkoInfiniteToggle = document.getElementById('plinkoInfiniteToggle');
  const plinkoBetInput = document.getElementById('plinkoBetInput');
  const plinkoDropBtn = document.getElementById('plinkoDropBtn');
  const plinkoCanvas = document.getElementById('plinkoCanvas');
  const plinkoPayouts = document.getElementById('plinkoPayouts');
  const plinkoHistory = document.getElementById('plinkoHistory');

  // Payouts: [left, ..., center, ..., right]
  const plinkoPayoutArr = [10, 2, 1, 0.5, 0.2, 0.5, 1, 2, 10];
  function renderPlinkoPayouts() {
    plinkoPayouts.innerHTML = '';
    for (let i = 0; i < plinkoPayoutArr.length; ++i) {
      const div = document.createElement('div');
      div.className = 'plinko-payout';
      div.textContent = plinkoPayoutArr[i] + 'x';
      plinkoPayouts.appendChild(div);
    }
  }
  function renderPlinkoBalance() {
    plinkoBalanceDisplay.textContent = state.infinite ? 'â' : fmt(state.balance);
  }
  function renderPlinkoHistory() {
    plinkoHistory.innerHTML = '';
    if (state.plinkoHistory.length === 0) {
      plinkoHistory.innerHTML = '<div>No history yet.</div>';
      return;
    }
    for (let i = state.plinkoHistory.length - 1; i >= 0; --i) {
      const h = state.plinkoHistory[i];
      const color = h.payout > 1 ? 'style="color:#7af0c2;"' : '';
      plinkoHistory.innerHTML += `<div ${color}>${h.result} (${h.payout}x) ${h.profit >= 0 ? '+' : ''}${fmt(h.profit)}</div>`;
    }
  }

  // Plinko physics
  const ROWS = 8;
  const COLS = plinkoPayoutArr.length;
  const PEG_RADIUS = 7;
  const BALL_RADIUS = 10;
  const SLOT_HEIGHT = 40;
  const PEG_Y_START = 60;
  const CANVAS_W = plinkoCanvas.width;
  const CANVAS_H = plinkoCanvas.height;
  const SLOT_W = CANVAS_W / COLS;

  let plinkoBall = null;
  let plinkoAnim = null;

  function resetPlinko() {
    plinkoBall = null;
    if (plinkoAnim) cancelAnimationFrame(plinkoAnim);
    drawPlinko();
  }

  function dropPlinkoBall() {
    if (plinkoBall) return;
    const bet = Math.floor(Number(plinkoBetInput.value));
    if (!Number.isFinite(bet) || bet < 1) {
      alert('Enter a valid bet');
      return;
    }
    if (!state.infinite && bet > state.balance) {
      alert('Not enough balance');
      return;
    }
    if (!state.infinite) state.balance -= bet;
    renderPlinkoBalance();
    saveState();

    // Ball starts at center
    plinkoBall = {
      x: CANVAS_W / 2,
      y: 30,
      vx: 0,
      vy: 2,
      bet: bet,
      path: [],
      finished: false
    };
    animatePlinko();
  }

  function animatePlinko() {
    if (!plinkoBall) return;
    plinkoBall.vy += 0.08; // gravity
    plinkoBall.y += plinkoBall.vy;
    plinkoBall.x += plinkoBall.vx;

    // Collide with pegs
    for (let row = 0; row < ROWS; ++row) {
      const y = PEG_Y_START + row * SLOT_HEIGHT;
      if (Math.abs(plinkoBall.y - y) < PEG_RADIUS + BALL_RADIUS && !plinkoBall.path[row]) {
        // Pegs are staggered
        let pegCount = COLS - (row % 2);
        for (let col = 0; col < pegCount; ++col) {
          let px = SLOT_W * (col + 0.5) + (row % 2 ? SLOT_W / 2 : 0);
          let py = y;
          let dx = plinkoBall.x - px;
          let dy = plinkoBall.y - py;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < PEG_RADIUS + BALL_RADIUS) {
            // Bounce left or right randomly, but bias to simulate real plinko
            let dir = Math.random() < 0.5 ? -1 : 1;
            if (plinkoBall.x < px) dir = -1;
            if (plinkoBall.x > px) dir = 1;
            plinkoBall.vx = dir * (Math.random() * 2 + 1.5);
            plinkoBall.vy *= 0.7;
            plinkoBall.path[row] = true;
            break;
          }
        }
      }
    }

    // Collide with walls
    if (plinkoBall.x < BALL_RADIUS) {
      plinkoBall.x = BALL_RADIUS;
      plinkoBall.vx = Math.abs(plinkoBall.vx) * 0.7;
    }
    if (plinkoBall.x > CANVAS_W - BALL_RADIUS) {
      plinkoBall.x = CANVAS_W - BALL_RADIUS;
      plinkoBall.vx = -Math.abs(plinkoBall.vx) * 0.7;
    }

    // Land in slot
    if (plinkoBall.y > CANVAS_H - 30) {
      // Find slot
      let slot = Math.floor(plinkoBall.x / SLOT_W);
      slot = Math.max(0, Math.min(COLS - 1, slot));
      let payout = plinkoPayoutArr[slot];
      let profit = Math.floor(plinkoBall.bet * payout) - plinkoBall.bet;
      if (!state.infinite) state.balance += Math.floor(plinkoBall.bet * payout);
      renderPlinkoBalance();
      saveState();
      let result = payout > 1 ? 'Win' : (payout === 1 ? 'Push' : 'Loss');
      state.plinkoHistory.push({ result, payout, profit });
      renderPlinkoHistory();
      plinkoBall.finished = true;
      setTimeout(resetPlinko, 1200);
    }

    drawPlinko();
    if (!plinkoBall.finished) {
      plinkoAnim = requestAnimationFrame(animatePlinko);
    }
  }

  function drawPlinko() {
    const ctx = plinkoCanvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

    // Draw slots
    for (let i = 0; i < COLS; ++i) {
      ctx.save();
      ctx.fillStyle = 'rgba(122,240,194,0.08)';
      ctx.fillRect(i * SLOT_W, CANVAS_H - 30, SLOT_W, 30);
      ctx.restore();
    }
    // Draw payout labels
    ctx.save();
    ctx.font = 'bold 15px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#7af0c2';
    for (let i = 0; i < COLS; ++i) {
      ctx.fillText(plinkoPayoutArr[i] + 'x', i * SLOT_W + SLOT_W / 2, CANVAS_H - 10);
    }
    ctx.restore();

    // Draw pegs
    for (let row = 0; row < ROWS; ++row) {
      let pegCount = COLS - (row % 2);
      let y = PEG_Y_START + row * SLOT_HEIGHT;
      for (let col = 0; col < pegCount; ++col) {
        let x = SLOT_W * (col + 0.5) + (row % 2 ? SLOT_W / 2 : 0);
        ctx.beginPath();
        ctx.arc(x, y, PEG_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = '#fff3';
        ctx.fill();
        ctx.strokeStyle = '#7af0c2';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // Draw ball
    if (plinkoBall) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(plinkoBall.x, plinkoBall.y, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#7af0c2';
      ctx.shadowColor = '#7af0c2';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.restore();
    }
  }

  plinkoDropBtn.onclick = dropPlinkoBall;
  plinkoInfiniteToggle.onchange = () => {
    state.infinite = plinkoInfiniteToggle.checked;
    renderPlinkoBalance();
    saveState();
  };

  // --- Sync infinite toggles and balance ---
  function syncTogglesAndBalance() {
    infiniteToggle.checked = state.infinite;
    plinkoInfiniteToggle.checked = state.infinite;
    renderBalance();
    renderPlinkoBalance();
  }

  // --- Initial Render ---
  renderBalance();
  renderHistory();
  renderPlinkoPayouts();
  renderPlinkoBalance();
  renderPlinkoHistory();
  syncTogglesAndBalance();
  drawPlinko();

  // --- Keep toggles in sync ---
  infiniteToggle.addEventListener('change', syncTogglesAndBalance);
  plinkoInfiniteToggle.addEventListener('change', syncTogglesAndBalance);

  // --- Show Mines by default ---
  showGame('mines');
})();
</script>
</body>
</html>
